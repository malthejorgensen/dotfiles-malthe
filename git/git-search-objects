#!/usr/bin/env -S uv run --script
import argparse
import os
import re
import subprocess


def find_matching_parent_dir(needle: str):
    full_path = os.getcwd()
    relative_dirs = []
    dirs = []

    current_path = full_path
    while True:
        parent_dir_path = os.path.dirname(current_path)
        parent_dir_name = os.path.basename(parent_dir_path)

        if current_path == parent_dir_path:
            # Reached the root directory
            break

        if os.path.exists(os.path.join(parent_dir_path, needle)):
            break

        relative_dirs.append("..")

        dirs.append(parent_dir_name)
        current_path = parent_dir_path

    full_parts = list(reversed(dirs))
    # relative_path = os.path.join(*full_parts)
    relative_path = os.path.join(*relative_dirs)

    return relative_path


def run_cmd(cmd: str, text: bool = True, stdin: bytes | str | None = None):
    result = subprocess.run(
        cmd.split(" "),
        capture_output=True,
        text=text,
        input=stdin,
    )
    if result.returncode != 0:
        print(result.stderr)
        exit(1)

    return result.stdout


def parse_git_tree_file(contents: bytes):
    RE_FILE = re.compile(
        b"(?P<mode>[0-7]{5,6}) (?P<filename>[^\0]+)\0(?P<sha1>.{20})",
        flags=re.DOTALL,
    )
    matches = []
    for match in RE_FILE.finditer(contents):
        matches.append((match.group("filename"), match.group("sha1")))

    # DEBUG: print(len(matches), len(re.findall(b"\0", contents)))
    # There are often \0 characters in the `sha1` bytes, so the \0 doesn't necessarily match.
    return matches


def main(file: str, all_objects: bool):
    git_dir = find_matching_parent_dir(".git")
    object_files = run_cmd(f"find {git_dir}/objects -type f").strip().split("\n")
    objects = [
        o.replace(f"{git_dir}/objects/", "").replace("/", "")
        for o in object_files
        if "pack" not in o
    ]

    if all_objects:
        for object in objects:
            print(object)
        return

    # Get contents of all trees
    git_stdin = b"\0".join([f"contents {obj}".encode("utf8") for obj in objects])
    trees_full = run_cmd(
        "git cat-file --batch-command --filter=object:type=tree -Z",
        text=False,
        stdin=git_stdin,
    )

    RE_EXCLUDED = re.compile(b"(^|\0)(?P<object_hash>[0-9a-f]{40}) excluded($|\0)")
    trees_full = RE_EXCLUDED.sub(b"\0", trees_full)
    # Run twice due to overlaps in matches
    trees_full = RE_EXCLUDED.sub(b"\0", trees_full)

    # DEBUG
    # print(b"\n".join(trees_full.split(b"\0")).decode("utf-8", errors="replace"))
    # exit()

    # It's quite important that we DO NOT capture here, as any capture group
    # will make `.split()` return a "split" group as well.
    RE_TREE = re.compile(b"(?:^|\0)(?:[0-9a-f]{40}) tree \\d{2,3}(?:$|\0)")
    trees = [t for t in RE_TREE.split(trees_full) if t.strip()]

    # Parse trees
    matches = set()
    file_bytes = file.encode("utf-8")
    print(f"Found {len(trees)} trees in `.git/objects/`")
    for tree_content in trees:
        files = parse_git_tree_file(tree_content)
        for filename, hash in files:
            if filename == file_bytes:
                matches.add(hash.hex())

    # Print matches
    print(f"Found {len(matches)} in `.git/objects/`")
    for object in matches:
        object_content = run_cmd(f"git cat-file -p {object}")
        print(f"========================== {object} ==========================")
        print(object_content)


if __name__ == "__main__":
    parser = argparse.ArgumentParser("Searches .git/objects for a particular file")
    parser.add_argument("file", nargs="?", help="File to search for in git objects")
    parser.add_argument("--all-objects", action="store_true", help="All objects")

    args = parser.parse_args()

    main(file=args.file, all_objects=args.all_objects)
